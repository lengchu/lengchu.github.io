[{"title":"JavaScript原型相关知识总结","date":"2020-05-05T11:50:16.000Z","path":"2020/05/05/JavaScript/prototype/","text":"JavaScript原型相关知识，很久以前学习过一次，后来慢慢的就忘了，这次又学习了一次，总结一下加深记忆，便于下次快速学习 总结 除去四种基本的值类型(undefined, number, string, boolean)，一切皆是对象 所有对象都是通过函数创建的，同时函数也是一种对象 每个函数都有一个都有一个属性prototype，这个属性指向一个对象，该对象也都有一个属性constructor，指向函数本身 每个对象也都有一个属性__proto__，指向创建该对象的函数的prototype Object.prototype的__proto__指向null 一些代码帮助理解上述结论12345678910111213141516function fn () &#123;&#125;fn.prototype.constructor === fn // trueconst obj = new fn()obj.__proto__ === fn.prototype // trueconst obj2 = &#123;&#125;obj2.__proto__ === Object.prototype // truefn.__proto__ === Function.prototype // trueFunction.__proto__ === Function.prototype // trueFunction.prototype.__proto__ === Object.prototype // trueObject.__proto__ === Function.prototype // trueObject.prototype.__proto__ === null // true 参考 https://www.cnblogs.com/wangfupeng1988/p/3977924.html","tags":[{"name":"JavaScript, 原型","slug":"JavaScript-原型","permalink":"https://lenchu.gitee.io/tags/JavaScript-原型/"}]},{"title":"线程协作初步","date":"2019-05-08T20:31:35.000Z","path":"2019/05/09/java/线程协作初步/","text":"问题引入用三个线程分别打印三次A, B, C, 要求保证其打印的顺序, 即打印出ABCABCABC 没错又是一道面试题, 后来学习了一些线程知识, 就突然想到这道题 解决方案用ReentrantLock绑定多个Condition来实现线程协作 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ABC &#123; static Lock lock = new ReentrantLock(); static Condition ca = lock.newCondition(); static Condition cb = lock.newCondition(); static Condition cc = lock.newCondition(); public static void main(String[] args) &#123; A a = new A(); B b = new B(); C c = new C(); ExecutorService executor = Executors.newCachedThreadPool(); executor.execute(a); executor.execute(b); executor.execute(c); lock.lock(); try &#123; ca.signal(); &#125; finally &#123; lock.unlock(); &#125; executor.shutdown(); &#125; static class A implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; lock.lock(); try &#123; ca.await(); System.out.print(\"A\"); cb.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125; static class B implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; lock.lock(); try &#123; cb.await(); System.out.print(\"B\"); cc.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125; static class C implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; lock.lock(); try &#123; cc.await(); System.out.print(\"C\"); ca.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125;&#125; 试着运行了一下, 完美解决 新问题本以为完美解决了, 整个人沉浸在获得新知识的愉悦中, 情不自禁的多运行了几次 结果发现并不是每次都能完美运行, 偶尔会出现死锁… 随着学习的深入, 以后再来解决这个问题 如有大佬随手指点迷津, 愚不胜感激 :)","tags":[{"name":"Java","slug":"Java","permalink":"https://lenchu.gitee.io/tags/Java/"}]},{"title":"try-catch-finally中的return","date":"2019-04-29T14:00:48.000Z","path":"2019/04/29/java/try-catch-finally中的return/","text":"try-catch-finallytry: 正常执行的语句 catch: try中抛出相应的异常时执行的语句 finally: 不管执行的是try还是catch, 最终都会执行的语句 先回顾以上基础 AutoClose从jdk1.7开始, 可以在try后面加一对圆括号, 把要关闭的资源放到圆括号里声明, 可以自动关闭 123456789File f = new File(\"test\");try ( InputStream is = new FileInputStream(f); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr);) &#123; br.readLine();&#125; catch (Exception e) &#123;&#125; 自动关闭的资源需要实现AutoCloseable接口 实际上AutoCloseable接口是jdk1.7新增的, 而Closeable接口继承自AutoCloseable, 所以只要实现Closeable接口即可 带有return语句的try-catch-finally12345678910public static int tryCatchFinally() &#123; int a = 1, b = 2; try &#123; return ++a + b; &#125; catch(Exception e) &#123; return a; &#125; finally &#123; return b; &#125;&#125; 使用javap反编译字节码, 部分如下 1234567891011121314151617Code: stack=1, locals=3, args_size=0 0: iconst_1 1: istore_0 2: iconst_2 3: istore_1 4: iinc 0, 1 7: goto 15 10: astore_2 11: goto 15 14: pop 15: iload_1 16: ireturn Exception table: from to target type 4 10 10 Class java/lang/Exception 4 14 14 any 大致意思: 如果代码4到10(try中的语句)发生异常(catch中捕获的异常)就跳转到10继续运行 如果代码4到14(try和catch)发生异常(任何异常)就跳转到14继续运行 如果不发生异常, 会在7执行goto, 跳转至15 或者try发生异常被catch捕获, 那就会在11执行goto, 跳转至15 所以最终执行的return语句是finally中的return try-catch中有return, finally中无return123456789int a = 1, b = 2;try &#123; return a;&#125; catch(Exception e) &#123; return b;&#125; finally &#123; a = 10; b = 20;&#125; 在finally中对a和b赋值, 在try和catch中返回a和b 结果return的a和b是1和2, 赋值语句也确实执行了, 只是未能对返回结果造成影响 具体什么情况呢? 还是看字节码 1234567891011121314151617181920212223242526272829303132333435Code: stack=1, locals=5, args_size=0 0: iconst_1 1: istore_0 2: iconst_2 3: istore_1 4: iload_0 5: istore 4 7: bipush 10 9: istore_0 10: bipush 20 12: istore_1 13: iload 4 15: ireturn 16: astore_2 17: iload_1 18: istore 4 20: bipush 10 22: istore_0 23: bipush 20 25: istore_1 26: iload 4 28: ireturn 29: astore_3 30: bipush 10 32: istore_0 33: bipush 20 35: istore_1 36: aload_3 37: athrow Exception table: from to target type 4 7 16 Class java/lang/Exception 4 7 29 any 16 20 29 any 与上次不同的是: 这次的字节码没有goto指令 两个ireturn指令把把这段逻辑分成了三部分, 分别对应try, catch, 和未catch的异常情况 finally中的语句都在ireturn或athrow之前被执行 至于为什么finally中的语句未对返回值造成影响, 三段也都一样, 这里挑try中的指令来看一下 123456784: iload_0 // 把0位置的变量(a)值推入栈顶5: istore 4 // 把栈顶值存入4位置变量7: bipush 10 // 把单字节常量值10推入栈顶9: istore_0 // 把栈顶值赋给0位置变量(a)10: bipush 2012: istore_1 // 同上13: iload 4 // 把4位置变量值推入栈顶15: ireturn // 返回栈顶值 总结一下就是: 当在try或catch中返回将在finally中要修改的基本类型变量时, 虚拟机会缓存将要返回的值, 再执行finally中的语句修改变量 为什么要这样设计呢感觉这个有点类似上一篇内部类访问局部变量为什么必须要用final修饰中的原因 为了消除代码的不确定性, 保持代码的简单易懂","tags":[{"name":"Java","slug":"Java","permalink":"https://lenchu.gitee.io/tags/Java/"}]},{"title":"内部类访问局部变量为什么必须要用final修饰","date":"2019-04-21T05:14:31.000Z","path":"2019/04/21/java/内部类访问局部变量为什么必须要用final修饰/","text":"内部类访问局部变量为什么必须要用final修饰 看了大概五六篇博客, 讲的内容都差不多, 讲的内容也都很对, 但我觉得有些跑题了 略叙一下 12345678910String s = \"hello\";class Inner implements Runnable &#123; public void run() &#123; System.out.println(s); &#125;&#125;// s = \"world\";Thread t = new Thread(new Inner());t.start(); jdk1.8及后续版本可以不显式声明final 所以以上代码在Java8是可以编译运行的, 但是如果在Inner类声明后再对s赋值, 就会报此错误Local variable s defined in an enclosing scope must be final or effectively final 所以, 尽管Java8以后不用显式声明为final, 但是内部类引用的变量实际上还是final的 内部类中存在要用到的外部变量的引用, 存于内部类成员变量中, 在内部类构造时传入 这点可以通过反射或者直接查看字节码证实 内部类中有了所需变量的引用, 那么在方法执行完之后, 依然可以访问到此变量 可以说是摆脱了方法内部变量作用域对内部类变量使用的限制(啰嗦解释一句, 如果内部没有保存引用, 那么方法执行完毕, 方法内所有本地变量随方法所在栈帧销毁, 内部类将无法获取这一引用) 为了保证内部的引用与外部的引用指向一致, 所以必须是final 这一点最接近题意 但是他们大多只解释了为了使内部与外部保持一致 我的理解 使内部与外部保持一致不是必要的 1234567891011121314151617public static void main(String[] args) &#123; String name = \"lengchu\"; class Inner &#123; String name; Inner(String name) &#123; this.name = name; &#125; void sayHi() &#123; System.out.println(\"hello \" + name); &#125; &#125; name = \"lenchu\"; new Inner(name).sayHi();&#125; 开头那段代码编译成字节码后和这段其实差不多 内部的name字段和构造器是编译器为我们加上的, 实例化的时候构造器里的值也是编译器给我们传过去的 如果把编译器为我们做的这些我们自己手动实现了, 再来看这个所谓的使内部与外部保持一致的需求是多么的无理, 完全就没必要嘛 所以到底为什么呢 个人理解 为了消除代码的不确定性, 保持代码的简单易懂 怎么说呢? 我们把上面实例化和调用那段代码稍作修改 123Inner i = new Inner(name);name = \"lenchu\";i.sayHi(); 因为构造器和内部字段是我们自己实现的, 所以我们可以轻松判断此时修改name对i的值是没有影响的 但是如果我们不自己实现这些呢 123456789101112public static void main(String[] args) &#123; String name = \"lengchu\"; class Inner &#123; void sayHi() &#123; System.out.println(\"hello \" + name); &#125; &#125; Inner i = new Inner(); // name = \"lenchu\"; i.sayHi();&#125; 假如可以对name重新赋值 那么name运行的时候name到底是谁呢 从上面的分析我们可以知道name的值应该是内部类实例化时的值 但是从执行顺序上看难免多少会有些歧义 干脆就不让他改了吧–!(个人见解不代表官方意见) 强行对比一波js的上下文环境 1234567891011function fn() &#123; let i = 0 let ret = function() &#123; return i++ &#125; return ret&#125;let i = 10let inc = fn()inc() // 0 Java的运行是基于方法栈, 而js则是基于执行上下文栈 二者有很多相似之处, 略叙一下 Java的每个方法调用都会往方法栈里推入一帧,这一栈帧里存放着方法内部声明的局部变量, 方法参数等,方法执行完毕时, 栈帧出栈, 栈帧里的内容随之销毁 js的上下文栈也与之类似 js的栈帧未必会随着上下文执行完毕而销毁 如上例,fn执行完毕, 他的上下文就不会销毁,如果销毁, 那么ret执行的时候变量i就找不到其所指了 栈帧销毁, 变量找不到引用, 像极了Java方法栈帧销毁, 内部类变量找不到引用 栈帧未必销毁, 那怎么知道当前上下文所用的帧呢 标记, 标记当前上下文所用的栈帧为active 同时还会标记每一帧的上一帧,这样就以另一种方式解决了类似的问题","tags":[{"name":"Java","slug":"Java","permalink":"https://lenchu.gitee.io/tags/Java/"}]},{"title":"String为什么是不可变的","date":"2019-04-19T08:10:17.000Z","path":"2019/04/19/java/String为什么是不可变的/","text":"前几天一个面试被问到String为什么是不可变的?, 自我感觉当时回答的不太理想, 事后总结一下 不可变的是什么我们谈论的String不可变, 指的是字符串的值不可变 例: String s = &quot;hello&quot; s的值就是hello, 不可变也指的是这个值不可变 类比到int基本类型就相当于int i = 1, 假如这里i的值不可变, 那指的就是1不可变 为什么不可变众所周知Java的String类型并非基本类型, 即String是一个类 既然String是类, 那我们就深入其内部实现来一探究竟 1234567public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; //......&#125; 从源码来看, String类内部是用char数组来保存字符串的值, 并且char[]是final的, 这里的final意味着什么呢? value必须在构造时为其赋值 赋值后value的引用不能再变 当我们实例化一个String对象并得到其引用后, 构造已经结束了, 即value的引用已经不能再变了 那么value的值呢, 理论上是可以改变的, 只要我们拿到value的引用, 可以直接通过下标改变他的值 实际上呢? value的值我们从String外部获取不到 首先, 构造的时候我们传入String的值, String内部赋值给value字段的时候都经过copy, 也就是说我们传给String的值经过构造后已经有了一份我们获取不到的备份留在了String内部, 我们改变原来的值对String内部的value已经毫无影响 123456char[] c = new char[32];c[0] = 'h';String s = new String(c);System.out.println(s);c[1] = 'e';System.out.println(s); 毫无疑问, 两次的输出都是h 其次, String类没有提供对外的接口来改变value的值, 通过查看String类源码可以看到, String类所有的公开方法中, 没有一个可以修改value的值 最后 12String s = \"hello\";s = \"world\"; 这种情况, s的值貌似改变了, 从hello变成了world 其实这里s所改变的是他所引用的对象, 并不是String对象的值改变了 怎么说呢? 我们这样String s = &quot;hello&quot;写代码只是一种简写, 或者称为’语法糖’ 实际执行的时候是什么样子的呢? 非要用Java代码表示的话大致意思是这样String s = String.valueOf(&quot;hello&quot;) 嗯? 这样表述貌似也有些问题… 改天再单独总结… 这里意思就是valueOf(&quot;hello&quot;)会返回一个内部的value字段存的是”hello”的String对象 从上面几点分析我们知道, 拿到String对象的时候, 内部的value字段已经无法修改了 那么这里的s = &quot;world&quot;, 这个赋值又是什么意思呢? 根据上面对valueOf的分析, 这里的s = &quot;world&quot;赋值之后s是一个内部字段存的是”world”的String对象 又因为value的值在String构造的时候就已经指定且不可再变, 所以这个s和之前的s引用的必然不是同一个对象 综上, 对s赋值是改变了s所引用的对象, 而改变前后两个String对象既不是同一个对象, 内部的value值又不一样 所以, 直接赋值也不能改变字符串的值, 改变的只是引用 所以, String不可变. 真的不可变吗?按照上述的分析, 貌似真的不可变 因为一般情况下我们获取不到String内部的value数组的引用 那么二般情况呢 123456789101112131415161718char[] origin = new char[32];origin[0] = 'h';String s = new String(origin);System.out.println(s);try &#123; Field f = s.getClass().getDeclaredField(\"value\"); f.setAccessible(true); Object o = f.get(s); if(o instanceof char[]) &#123; char[] c = (char[]) o; System.out.println(c.length); c[1] = 'e'; c[2] = 'l'; System.out.println(s); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 利用反射我们可以直接获取类内部的属性, 挣脱了访问权限的束缚 获取了String内部的value数组, 改变了String的值 假如以后遇到别的改变String值的方法, 再来记录","tags":[{"name":"Java","slug":"Java","permalink":"https://lenchu.gitee.io/tags/Java/"}]},{"title":"c++数组相关","date":"2018-11-09T02:44:31.000Z","path":"2018/11/09/cpp/cpp-array/","text":"问题从获取数组的长度开始 数组长度的获取12int arr[] = &#123;1, 2, 3, 4, 5&#125;;cout &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; // 5 数组元素的类型是确定的，所以每个元素的大小都是一样的 所以数组长度 = 数组总大小 / 单个元素大小 于是写个函数获取数组长度123456int arrSize(int[] arr) &#123; return sizeof(arr) / sizeof(arr[0]);&#125;int arr[] = &#123;1, 2, 3, 4, 5&#125;;cout &lt;&lt; arrSize(arr) &lt;&lt; endl; // 2 ??? 数组作为参数在函数间传递时，传递的只是第一个元素的地址1234567int arrSize(int[] arr) &#123; cout &lt;&lt; *arr &lt;&lt; endl; return sizeof(arr) / sizeof(arr[0]);&#125;int arr[] = &#123;1, 2, 3, 4, 5&#125;;arrSize(arr) // 1 然后想起了引用 然后发现不能声明素组的引用 翻阅资料得到解释 数组名arr只代表数组首元素的地址，本身不是一个占有存储空间的变量，所以不能建立数组的引用 这时想起了刚刚百度时看到的template1234567template&lt;typename T&gt;int arrSize(T&amp; arr) &#123; return sizeof(arr) / sizeof(arr[0]);&#125;int arr[] = &#123;1, 2, 3, 4, 5&#125;;cout &lt;&lt; arrSize(arr) &lt;&lt; endl; // 5 ??? int arrSize(T&amp; arr) 使用函数模板可以获取数组的引用? 貌似只有这种解释 - - !","tags":[{"name":"c++","slug":"c","permalink":"https://lenchu.gitee.io/tags/c/"}]},{"title":"linux 文件监控设置","date":"2018-10-10T13:36:02.000Z","path":"2018/10/10/linux/fs-inotify/","text":"检查现有文件监控数量tac /proc/sys/fs/inotify/max_user_watches 修改文件监控数目 打开配置文件sudo vi /etc/sysctl.conf 添加配置fs.inotify.max_user_watches=[数量] 使配置生效sudo sysctl -p 参考 https://blog.csdn.net/davidhopper/article/details/79620425","tags":[{"name":"linux","slug":"linux","permalink":"https://lenchu.gitee.io/tags/linux/"}]},{"title":"ssh免密登录","date":"2018-08-23T01:06:03.000Z","path":"2018/08/23/linux/ssh/","text":"先在本机生成密钥ssh-keygen -t rsa 然后将公钥复制到目标主机的相应用户ssh-copy-id -i ~/.ssh/id_rsa.pub [用户]@[目标主机地址] 最后就可以免密登录了ssh [用户]@[地址]]","tags":[{"name":"linux","slug":"linux","permalink":"https://lenchu.gitee.io/tags/linux/"}]},{"title":"linux命令笔记","date":"2018-08-22T08:45:41.000Z","path":"2018/08/22/linux/linux-cmd/","text":"一些用过的命令笔记 修改默认shell12345678910➜ ~ cat /etc/shells # /etc/shells: valid login shells/bin/sh/bin/bash/bin/rbash/bin/dash/bin/zsh/usr/bin/zsh➜ ~ chsh -s /bin/bash [user] scp 远程拷贝文件从远程拷贝到本地:scp lenchu@lenchu.cn:/home/lenchu/test.txt /home/lenchu/从本地拷贝到远程:scp /home/lenchu/test.txt lenchu@lenchu.cn:/home/lenchu/","tags":[{"name":"linux","slug":"linux","permalink":"https://lenchu.gitee.io/tags/linux/"},{"name":"shell-cmd","slug":"shell-cmd","permalink":"https://lenchu.gitee.io/tags/shell-cmd/"}]},{"title":"用户管理命令笔记","date":"2018-08-22T08:32:32.000Z","path":"2018/08/22/linux/user-operation/","text":"增加用户:useradd -d /home/username -m username 为用户添加密码:passwd username 为用户添加组:usermod -G groupname username 删除用户:userdel -rf username-rf 是同时删除用户的家","tags":[{"name":"linux","slug":"linux","permalink":"https://lenchu.gitee.io/tags/linux/"}]},{"title":"字符串操作","date":"2018-08-20T07:10:21.000Z","path":"2018/08/20/shell/string/","text":"获取字符串长度12345➜ ~ str=hello ➜ ~ echo $&#123;#str&#125;5➜ ~ expr length $str5 字符串所在位置12345678910111213141516171819➜ ~ echo $strhello➜ ~ expr index $str h1➜ ~ expr index $str l3➜ ~ expr index $str o5➜ ~ expr index $str w0➜ ~ expr index $str he1➜ ~ expr index $str el2➜ ~ expr index $str ll3➜ ~ expr index $str lo3 expr好多字符串的操作都可以使用expr完成详情 man expr","tags":[{"name":"shell","slug":"shell","permalink":"https://lenchu.gitee.io/tags/shell/"}]},{"title":"git命令笔记","date":"2018-08-12T04:05:04.000Z","path":"2018/08/12/git-cmd/","text":"查看本地文件修改内容git diff fileName 使用多个远程仓库添加远程仓库git remote add origin git@github.com:lengchu/novel-java.git 为远程仓库添加地址git remote set-url --add origin git@gitee.com:lenchu/novel-java.git 或者定义多个远程仓库git remote add gitee git@github.com:lengchu/novel-java.git 删除分支git branch -d [分支名] git 标签推送本地标签到远程库git push origin --tags 查看分支git tag 查看分支详情git show tagName","tags":[{"name":"git","slug":"git","permalink":"https://lenchu.gitee.io/tags/git/"}]},{"title":"Hello World","date":"2018-08-07T16:00:00.000Z","path":"2018/08/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]